---
import type { HTMLAttributes } from 'astro/types'
import { findImage } from '@/utils/image-utils'
import {
  getImagesOptimized,
  astroAsseetsOptimizer,
  unpicOptimizer,
  isUnpicCompatible,
  type ImageProps,
} from '@/utils/image-optimization'

type Props = ImageProps & { id?: string; position?: string; className?: string }
type ImageType = {
  src: string
  attributes: HTMLAttributes<'img'>
}

const props = Astro.props

if (props.alt === undefined || props.alt === null) {
  throw new Error()
}

if (typeof props.width === 'string') {
  props.width = parseInt(props.width)
}

if (typeof props.height === 'string') {
  props.height = parseInt(props.height)
}

if (!props.loading) {
  props.loading = 'lazy'
}

if (!props.decoding) {
  props.decoding = 'async'
}

const _image = await findImage(props.src)

let image: ImageType | undefined = undefined

if (
  typeof _image === 'string' &&
  (_image.startsWith('http://') || _image.startsWith('https://')) &&
  isUnpicCompatible(_image)
) {
  image = await getImagesOptimized(_image, props, unpicOptimizer)
} else if (_image) {
  image = await getImagesOptimized(_image, props, astroAsseetsOptimizer)
}

const imageClass = 'w-full h-full object-cover'
const imageStyle = `object-position: ${props.position}`
---

<div id={props.id} class:list={[props.className, 'overflow-hidden relative']}>
  <div
    class='transition absolute inset-0 dark:bg-black/10 bg-opacity-50 pointer-events-none'
  >
  </div>
  {
    !image ? (
      <Fragment />
    ) : (
      <img
        id={props.id}
        src={image.src}
        crossorigin='anonymous'
        referrerpolicy='no-referrer'
        class={imageClass}
        style={imageStyle}
        {...image.attributes}
      />
    )
  }
</div>

{}
